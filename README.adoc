Spring Fu is an **incubating** project that makes it easy to create https://spring.io/projects/spring-framework[Spring]-powered applications, micro-services and functions (Serverless) in https://kotlinlang.org/[**Kotlin**] with **https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way[functional configuration]**. The programming model is explicit and based on lambdas instead of annotations without requiring annotation processing to generate code at compile time.

Spring Fu is designed to allow efficient dead code removal and should provide https://github.com/oracle/graal[Graalvm] native image support. A simple Spring Fu web application starts in less than a second on modern hardware, consumes only 16M of heap memory, and self-executable shrinked JAR is less than 10M.

A minimal core is enabled by default and configuration is always explicit. Spring Fu https://github.com/sdeleuze/spring-fu/tree/master/modules[modules] provides integration for various JVM technologies by providing required dependencies and modular functional configuration.

It also leverages https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux[Spring WebFlux] and Spring Data Reactive support to allow developing scalable applications, and give the choice to use powerful https://projectreactor.io/[Reactor] `Flux` and `Mono` Reactive for Reactive programming or Kotlin https://kotlinlang.org/docs/reference/coroutines.html[Coroutines] for async imperative programming.

== Functional configuration

Here is an example of Spring Fu functional configuration.

```kotlin
val app = application {
	configuration {
	    AppConfiguration(name = env["SYSTEM_ENV"] ?: "default")
	}
	actuators(health = true, mapping = true)
	coroutines()
	profile("data") {
		bean<UserRepository>()
		bean<ArticleRepository>()
		mongodb(uri = "mongodb://myserver.com/foo")
	}
	profile("web") {
		bean<HtmlHandler>()
		bean<ApiHandler>()
		webflux {
			server(NettyWebServerModule()) {
				cors(origin = "example.com")
				mustache()
				codecs {
					jackson()
					protobuf()
				}
				routes(routes)
				security {
					// ...
				}
			}
			client {
				codecs {
					jackson()
				}
			}
		}
	}
}

data class AppConfiguration(
	val name: String
)


val routes = routes {
	val htmlHandler = ref<HtmlHandler>()
    val apiHandler = ref<ApiHandler>()
	GET("/", htmlHandler::blog)
	GET("/article/{id}", htmlHandler:article)
	"/api".nest {
		GET("/", apiHandler::list)
		POST("/", apiHandler::create)
		PUT("/{id}", apiHandler::update)
		DELETE("/{id}", apiHandler::delete)
	}
}

fun main(args: Array<String) {
	app.run(await = true, profiles = "data, web")
}
```

== Reference documentation

* https://github.com/sdeleuze/spring-fu/tree/master/core[Core]
* Modules
** https://github.com/sdeleuze/spring-fu/tree/master/modules/dynamic-configuration[Dynamic configuration]
** https://github.com/sdeleuze/spring-fu/tree/master/modules/jackson[Jackson]
** https://github.com/sdeleuze/spring-fu/tree/master/modules/mongodb[MongoDB]
** https://github.com/sdeleuze/spring-fu/tree/master/modules/mustache[Mustache]
** https://github.com/sdeleuze/spring-fu/tree/master/modules/test[Test]
** https://github.com/sdeleuze/spring-fu/tree/master/modules/webflux[WebFlux]
*** https://github.com/sdeleuze/spring-fu/tree/master/modules/webflux/netty[WebFlux Netty]
*** https://github.com/sdeleuze/spring-fu/tree/master/modules/webflux/tomcat[WebFlux Tomcat]

== Samples

* https://github.com/sdeleuze/spring-fu/tree/master/samples/simple-webapp[Simple webapp]

== Credits

Kudos to https://github.com/tgirard12[Thomas Girard] for its https://github.com/tgirard12/spring-webflux-kotlin-dsl[spring-webflux-kotlin-dsl] experiment that initially demonstrated this approach was possible.